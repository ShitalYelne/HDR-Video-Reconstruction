# -*- coding: utf-8 -*-
"""phase2plustonemapped.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1biG6i-J-i3B5bg1w4eN29MQzWcIXXsiT
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from tqdm.notebook import tqdm

def simulateCam(img1,rn,expTime):
    mimg = img1.astype(np.float64).copy()
    #Clamp the exposure time
    rn[rn>expTime] = expTime
    mimg[:,:,0] = np.multiply(mimg[:,:,0],rn)
    mimg[:,:,1] = np.multiply(mimg[:,:,1],rn)
    mimg[:,:,2] = np.multiply(mimg[:,:,2],rn)
     
    return mimg.astype(np.uint8)

def retrieveFrame(img2,rn):
    pimg2 = img2.copy()
    pimg2[:,:,0] = np.divide(pimg[:,:,0].astype(np.float64),rn)
    pimg2[:,:,1] = np.divide(pimg[:,:,1].astype(np.float64),rn)
    pimg2[:,:,2] = np.divide(pimg[:,:,2].astype(np.float64),rn)
    return pimg2.astype(np.uint8)

tonemap1 = cv2.createTonemap(gamma=2.2)
#include <opencv2/core/hal/interface.h>

path = 'ChristmasTree/{0}.hdr'.format(2917) 
img = cv2.imread(path)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

rn = np.ones(gray.shape,dtype=np.float64)    # Exposure time initially set to 1
expTime = 1.0

size = (2048, 1080)
videoPath = 'G:/Phase3CP/withouttonemapping.avi'
result = cv2.VideoWriter(videoPath,cv2.VideoWriter_fourcc(*'MJPG'),10, size)

for i in tqdm(range(2918,3234)):
    ln = np.divide(gray.astype(np.float64),rn) # Finding the light flux
    rn = 128.0/(ln + 1)
    
    path = 'ChristmasTree/{0}.hdr'.format(i) 
    img = cv2.imread(path)
 
    pimg = simulateCam(img,rn,expTime)
    gray = cv2.cvtColor(pimg,cv2.COLOR_BGR2GRAY)
    
    pimg2 = retrieveFrame(pimg,rn)
    #res_debevec_8bit = np.clip(pimg2*255, 0, 255).astype('uint8')
    #from skimage.util import img_as_float
    #image = img_as_float(pimg2)
    #res = np.float32(pimg2)
    #res_debevec = tonemap1.process(res.copy())
    #res_debevec_8bit = np.clip(res_debevec*255, 0, 255).astype('uint8')
    
    


    result.write(pimg2)
result.release()

print(pimg2.dtype)

plt.imshow(img)
pimg2.shape

print(pimg2)

for i in tqdm(range(2918,3000)):
    path = 'ChristmasTree/{0}.hdr'.format(i)
    img = cv2.imread(path)
    cv2.imshow("op",img)
    cv2.waitKey(10)
    
cv2.destroyAllWindows()

image = cv2.imread('./input.png')

# Read the desired model
path = "EDSR_x3.pb"
sr.readModel(path)

# Set the desired model and scale to get correct pre- and post-processing
sr.setModel("edsr", 3)

# Upscale the image
result = sr.upsample(image)

def mosaic(img):
    #BGGR mosaic is assumed
    op = np.zeros((img.shape[0],img.shape[1]),dtype=np.uint8)
    op[::2,::2] = img[::2,::2,2]
    op[1::2,1::2] = img[1::2,1::2,0]
    
    op[1::2,::2] = img[1::2,::2,1]
    op[::2,1::2] = img[::2,1::2,1]
    return op

# cnt = 2917
path = 'ChristmasTree/{0}.hdr'.format(2917) 
img = cv2.imread(path)
# gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

bimg1 = mosaic(img)
# dimg = cv2.cvtColor(bimg,cv2.COLOR_BAYER_BG2BGR)

rn = np.ones(bimg1.shape)    # Exposure time initially set to 1

# Should be in a loop
for i in tqdm(range(2918,2919)):
    ln = np.divide(bimg1.astype(np.float64),rn) # Finding the light flux
    rn = 128.0/(ln + 1)
    
    path = 'ChristmasTree/{0}.hdr'.format(i) 
#     print(path)
    img2 = cv2.imread(path)
    bimg2 = mosaic(img2)

    bmimg = np.multiply(bimg2.astype(np.float64),rn)
    pimg = cv2.cvtColor(bmimg.astype(np.uint8),cv2.COLOR_BAYER_BG2BGR)
    
    writePath = 'selectedFrames/phase2/{0}.jpg'.format(i)
    cv2.imwrite(writePath,pimg)