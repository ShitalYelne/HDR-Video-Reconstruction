# -*- coding: utf-8 -*-
"""phase3final_withoutopticalflow.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gC_UMLtwwAi627Gm1Jf67TEvNZzJA_GU
"""

import numpy as np

import os
import numpy as np
from random import sample
import imageio
import cv2 as cv
import matplotlib.pyplot as plt
from tqdm.notebook import tqdm

dataset = 'ChristmasTree'
for i in tqdm(range(2917,2918,1)): #3234
    print(i)
    path = '{0}/{1}.hdr'.format(dataset,i)
    img = cv.imread(path)

img.shape

col= len(img[0])
row=len(img)
print(col)
print(row)
arr = np.zeros((1,col),dtype=np.float32)    #Replace 15 by no. of cols

arr[0,0::3] = 0.5
arr[0,1::3] = 1
arr[0,2::3] = 2
# print(arr)
# print(arr.shape)
mask0=np.repeat(arr,row,axis=0)    #Replace 3 by no. of rows
mask0.shape

"""Generate next 3 masks by shifting the values
i.e. for mask 1
arr[0,0::3] = 1
arr[0,1::3] = 2
arr[0,2::3] = 0.5

For sake of identification of mask use mask number = frame_Number % 3
 and then multiply the pixels using the mask
This should simulate the output of the camera

Then use the code for task number 1. First divide the frame using the same mask, then directly use the code
"""

arr[0,0::3] = 1
arr[0,1::3] = 2
arr[0,2::3] = 0.5
# print(arr)
mask1=np.repeat(arr,row,axis=0)    #Replace 3 by no. of rows
mask1.shape

arr[0,0::3] = 2
arr[0,1::3] = 0.5
arr[0,2::3] = 1
# print(arr)
mask2=np.repeat(arr,row,axis=0)    #Replace 3 by no. of rows
mask2.shape

mask=[mask0,mask1,mask2]
# print(mask)

mask3d_1= np.array([mask0,mask0,mask0])
mask3d_1= np.transpose(mask3d_1,(1,2,0))
mask3d_2= np.array([mask1,mask1,mask1])
mask3d_2= np.transpose(mask3d_2,(1,2,0))
mask3d_3= np.array([mask2,mask2,mask2])
mask3d_3= np.transpose(mask3d_3,(1,2,0))
mask3d= [mask3d_1,mask3d_2,mask3d_3]

# dataset = 'ChristmasTree'
# for i in tqdm(range(2917,3233,1)): #3234
#     print(i)
#     path = '{0}/{1}.hdr'.format(dataset,i)
#     img = cv.imread(path)
#     x= i%3
#     #out = np.multiply(img,mask0)
#     #red = img[:, :, 0]
#     #green = img[:, :, 1]
#     #blue = img[:, :, 2]
#     (B, G, R) = cv.split(img)

#     out = np.multiply(B, mask[x])
#     out = np.multiply(G, mask[x])
#     out = np.multiply(R, mask[x])
#     result=cv.merge([B, G, R])
#     #out = out.astype(int)
#     path = 'G:/Phase3CP/codedFramesnew/CE{0}.jpg'.format(i)
#     cv.imwrite(path,result)

import cv2
merge_debevec = cv2.createMergeDebevec()
size = (2048, 1080)
dataset = 'ChristmasTree'
interval=1
videoPath = 'G:/Phase3CP/videoophase3withoutoptical{0}WCE.avi'.format(interval)
result = cv2.VideoWriter(videoPath,cv2.VideoWriter_fourcc(*'MJPG'),10, size)
exposure_times = np.array([0.25,0.5,1], dtype=np.float32)
tonemap1 = cv2.createTonemap(gamma=2.2)

for i in tqdm(range(2917,3230,1)): #3234
    print(i)

    path = '{0}/{1}.hdr'.format(dataset,i)    
    frame0 = cv.imread(path)

    path = '{0}/{1}.hdr'.format(dataset,i+1)    
    frame1 = cv.imread(path)

    path = '{0}/{1}.hdr'.format(dataset,i+2)    
    frame2 = cv.imread(path)
    
    x0 = i%3
    x1 = (i+1)%3
    x2 = (i+2)%3

    frame0m =np.multiply(frame0.astype("float32"), mask3d[x0])
    frame1m =np.multiply(frame1.astype("float32"), mask3d[x1])
    frame2m =np.multiply(frame2.astype("float32"), mask3d[x2])

    # Aligning the frames
#     frame0Gray = cv2.cvtColor(frame0, cv2.COLOR_BGR2GRAY)
#     frame1Gray = cv2.cvtColor(frame1, cv2.COLOR_BGR2GRAY)
#     frame2Gray = cv2.cvtColor(frame2, cv2.COLOR_BGR2GRAY)

#     frame0Gray = np.divide(frame0Gray,mask[x0])#.astype(np.uint8)
#     frame1Gray = np.divide(frame1Gray,mask[x1])#.astype(np.uint8)
#     frame2Gray = np.divide(frame2Gray,mask[x2])#.astype(np.uint8)

#     flow0To1 = cv2.calcOpticalFlowFarneback(frame0Gray, frame1Gray, None,0.5, 3, 15, 3, 5, 1.2, 0)
#     flow2To1 = cv2.calcOpticalFlowFarneback(frame2Gray, frame1Gray, None,0.5, 3, 15, 3, 5, 1.2, 0)

#     h = flow0To1.shape[0]
#     w = flow2To1.shape[1]
#     R2 = np.dstack(np.meshgrid(np.arange(w), np.arange(h)))
#     pixelMap0To1 = R2 + flow0To1
#     pixelMap2To1 = R2 + flow2To1

    #Estimating Frame 0 to Frame 1
#     frame1 = frame0.astype("float32")
#     pixelMap0To1 = pixelMap0To1.astype("float32")
    #frame0md
    frame0md= np.divide(frame0m,mask3d[x0])
    frame0md= frame0md*0.25
#     frame0To1 = cv2.remap(frame0md, pixelMap0To1, None, cv2.INTER_LINEAR)
#     #frame0To1 = np.divide(frame0To1,mask3d[x0])
#     frame0To1 = frame0To1*0.5
#     frame0To1 = frame0To1.astype(np.uint8)

    # Estimating Frame 2 to Frame 1
    # frame3 = frame3.astype("float32")
#     pixelMap2To1 = pixelMap2To1.astype("float32")
    frame2md= np.divide(frame2m,mask3d[x2])
    frame2md=frame2md*1
#     frame2To1 = cv2.remap(frame2md, pixelMap2To1, None, cv2.INTER_LINEAR)#.astype(np.uint8)
#     #frame2To1 = np.divide(frame2To1,mask3d[x2])
#     frame2To1 = frame2To1*1.25
#     frame2To1 = frame2To1.astype(np.uint8)

    frame1rm = np.divide(frame1m,mask3d[x1])
    frame1rm= frame1rm*0.5

    #images = [frame0To1.astype(np.uint8),frame1rm.astype(np.uint8),frame2To1.astype(np.uint8)]
    images = [frame0md.astype(np.uint8),frame1rm.astype(np.uint8),frame2md.astype(np.uint8)]

    hdr_debevec = merge_debevec.process(images, times=exposure_times.copy())
    res_debevec = tonemap1.process(hdr_debevec.copy())
    res_debevec_8bit = np.clip(res_debevec*255, 0, 255).astype('uint8')
    result.write(res_debevec_8bit)
    #result.write(frame2md.astype(np.uint8))
result.release()

images[2].dtype

import cv2
merge_debevec = cv2.createMergeDebevec()
size = (2048, 1080)
interval = 1
compensateExposure= True
exposure_times = np.array([0.5,1,2], dtype=np.float32)
#exposure_times = mask[x]

if(compensateExposure):
    videoPath = 'G:/Phase3CP/videoIntcheck6{0}WCE.avi'.format(interval)
else:
    videoPath = 'G:/Phase3CP/videoIntcheck6{0}WCE.avi'.format(interval)
result = cv2.VideoWriter(videoPath,cv2.VideoWriter_fourcc(*'MJPG'),10, size)

mask3d_1= np.array([mask0,mask0,mask0])
mask3d_1= np.transpose(mask3d_1,(1,2,0))
mask3d_2= np.array([mask1,mask1,mask1])
mask3d_2= np.transpose(mask3d_2,(1,2,0))
mask3d_3= np.array([mask2,mask2,mask2])
mask3d_3= np.transpose(mask3d_3,(1,2,0))
mask3d= [mask3d_1,mask3d_2,mask3d_3]
for i in range(2917,3233,1):
    if(i%10 == 0):
        print(i)
    if(i+2 > 3232):
        break
    path = 'G:/Phase3CP/codedFramesnew/CE{0}.jpg'.format(i)
    frame1 = cv2.imread(path)
    path = 'G:/Phase3CP/codedFramesnew/CE{0}.jpg'.format(i+1)
    frame2 = cv2.imread(path)
    path = 'G:/Phase3CP/codedFramesnew/CE{0}.jpg'.format(i+2)
    #path = .format(interval,i+interval)
    frame3 = cv2.imread(path)
    

    # Aligning the frames
    frame1Gray = cv2.cvtColor(frame1, cv2.COLOR_BGR2GRAY)
    frame2Gray = cv2.cvtColor(frame2, cv2.COLOR_BGR2GRAY)
    frame3Gray = cv2.cvtColor(frame3, cv2.COLOR_BGR2GRAY)
    x1=i%3
    x2=(i+1)%3
    x3=(i+2)%3

    if(compensateExposure):
        frame1Gray = np.divide(frame1Gray,mask[x1])
        frame2Gray = np.divide(frame2Gray,mask[x2])#.astype(np.uint8)
        frame3Gray = np.divide(frame3Gray,mask[x3])#.astype(np.uint8)

    flow1To2 = cv2.calcOpticalFlowFarneback(frame1Gray, frame2Gray, None,0.5, 3, 15, 3, 5, 1.2, 0)
    flow3To2 = cv2.calcOpticalFlowFarneback(frame3Gray, frame2Gray, None,0.5, 3, 15, 3, 5, 1.2, 0)

    h = flow1To2.shape[0]
    w = flow3To2.shape[1]
    R2 = np.dstack(np.meshgrid(np.arange(w), np.arange(h)))
    pixelMap1To2 = R2 + flow1To2
    pixelMap3To2 = R2 + flow3To2

    # Estimating Frame 1 to Frame 2
    frame1 = frame1.astype("float32")
    pixelMap1To2 = pixelMap1To2.astype("float32")
    frame1To2= np.divide(frame1To2,mask3d[x1])
    frame1To2=frame1To2*0.5
    frame1To2 = cv2.remap(frame1, pixelMap1To2, None, cv2.INTER_LINEAR).astype(np.uint8)

    
    # Estimating Frame 3 to Frame 2
    frame3 = frame3.astype("float32")
    pixelMap3To2 = pixelMap3To2.astype("float32")
    frame3To2= np.divide(frame3To2,mask3d[x3])
    frame3To2=frame3To2*2
    frame3To2 = cv2.remap(frame3, pixelMap3To2, None, cv2.INTER_LINEAR).astype(np.uint8)
    
    
    frame2= np.divide(frame2.astype("float32"),mask3d[x2]).astype(np.uint8)
    
    
    

    images = [frame1To2,frame2,frame3To2]
    
    
    #for i in tqdm(range(2917,3233,1)): #3234
              #x= i%3
    hdr_debevec = merge_debevec.process(images, times=exposure_times.copy())
    tonemap1 = cv2.createTonemap(gamma=2.2)
    res_debevec = tonemap1.process(hdr_debevec.copy())
    res_debevec_8bit = np.clip(res_debevec*255, 0, 255).astype('uint8')
    result.write(res_debevec_8bit)
result.release()

import cv2
path = 'G:/Phase3CP/codedFramesnew/CE{0}.jpg'.format(2917)
frame = cv2.imread(path)

frame1= np.divide(frame.astype("float32"),mask3d_1).astype(np.uint8)

plt.imshow(frame1)
#cv2.waitKey(0)

cv2.imshow("output",frame1)
cv2.waitKey(0)

cv2.imshow("input",frame)
cv2.waitKey(0)

dataset = 'ChristmasTree'
for i in tqdm(range(2917,2918,1)): #3234
    print(i)
    path = '{0}/{1}.hdr'.format(dataset,i)
    img = cv.imread(path)

image= np.multiply(img.astype("float32"),mask3d_1).astype(np.uint16)
#plt.imshow(image)

cv2.imshow("output1",image)
cv2.waitKey(0)
cv2.destroyAllWindows()

image2=np.divide(image.astype("float32"),mask3d_1).astype(np.uint8)

path1 ='G:/Phase3CP/codedFramesnew/new1.exr'
cv2.imwrite(path1,image)

import imageio
imageio.imwrite('G:/Phase3CP/codedFramesnew/new1.png',image)

image3=cv2.imread(path1)
#image2=np.divide(image3.astype("float32"),mask3d_1).astype(np.uint16)

cv2.imshow("output2",image2)
cv2.waitKey(0)
cv2.destroyAllWindows()

img_scaled = cv2.normalize(image2, dst=None, alpha=0, beta=255, norm_type=cv2.NORM_MINMAX)

img_scaled.max()

cv2.imshow("output3",img_scaled)
cv2.waitKey(0)
cv2.destroyAllWindows()

image2.dtype

image.dtype

image3.dtype

